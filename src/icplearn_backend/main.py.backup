from kybra import (Record, Variant, Vec, query, update, Opt, Principal, ic, StableBTreeMap, init, post_upgrade, pre_upgrade, void)
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime

# Candid type definitions for data structures

class User(Record):
    id: Principal
    username: str
    email: str
    btc_address: Opt[str]
    created_at: int

class Course(Record):
    id: str
    title: str
    description: str
    creator_id: Principal
    created_at: int
    updated_at: int
    content: str  # Could be markdown or JSON
    published: bool

class UserCourse(Record):
    id: str
    user_id: Principal
    course_id: str
    progress: int
    completed: bool
    started_at: int
    completed_at: Opt[int]

class Skill(Record):
    id: str
    name: str
    description: str
    category: str
    difficulty: str
    created_at: int

class UserSkill(Record):
    id: str
    user_id: Principal
    skill_id: str
    mastery_level: float
    last_practiced_at: int
    nft_issued: bool

class NeuroStake(Record):
    id: str
    user_id: Principal
    amount: float
    duration_days: int
    start_date: int
    end_date: int
    status: str  # e.g., 'active', 'completed', 'failed'
    streak: int
    last_check_in: int

class NftAttribute(Record):
    trait_type: str
    value: str

class GenesisNft(Record):
    id: str
    owner_id: Principal
    name: str
    description: str
    image_url: str
    attributes: Vec[NftAttribute]
    minted_at: int

class CombatArena(Record):
    id: str
    name: str
    description: str
    skill_id: str
    reward_pool: float
    created_at: int

class Battle(Record):
    id: str
    arena_id: str
    player1_id: Principal
    player2_id: Opt[Principal]
    status: str  # e.g., 'pending', 'active', 'completed'
    winner_id: Opt[Principal]
    questions: Vec[str]
    player1_answers: str  # JSON string for answers
    player2_answers: str  # JSON string for answers
    created_at: int
    started_at: Opt[int]
    completed_at: Opt[int]

class Reward(Record):
    id: str
    user_id: Principal
    battle_id: str
    amount: float
    claimed: bool
    created_at: int
    claimed_at: Opt[int]

class BitcoinReward(Record):
    id: str
    user_id: Principal
    amount: float
    skill_ids: Vec[str]
    reward_metadata: str  # JSON string
    created_at: int
    status: str  # e.g., 'pending', 'completed', 'claimed'
    transaction_hash: Opt[str]
    processed_at: Opt[int]
    wallet_address: Opt[str]
    claimed_at: Opt[int]

class SkillNft(Record):
    id: str
    owner_id: Principal
    skill_id: str
    name: str
    description: str
    image_url: str
    rarity: str
    attributes: Vec[NftAttribute]
    minted_at: int

class Assessment(Record):
    id: str
    title: str
    description: str
    skill_id: str
    creator_id: Principal
    time_limit_minutes: int
    created_at: int

class Question(Record):
    id: str
    assessment_id: str
    text: str
    question_type: str  # e.g., 'multiple_choice', 'true_false'
    options: Vec[str]
    correct_answer: str
    skill_tag: str

class UserAnswer(Record):
    id: str
    user_id: Principal
    question_id: str
    answer: str
    is_correct: bool
    answered_at: int

class AssessmentResult(Record):
    id: str
    user_id: Principal
    assessment_id: str
    score: float
    passed: bool
    started_at: int
    completed_at: int

class AIPrompt(Record):
    id: str
    user_id: Principal
    prompt_text: str
    context: str  # JSON string
    created_at: int

class AIResponse(Record):
    id: str
    prompt_id: str
    response_text: str
    model_used: str
    created_at: int

# Generic result types for returning either a success or error
class Error(Variant, aname='Error'):
    NotFound: str
    Unauthorized: str
    InvalidPayload: str
    Forbidden: str

class Result(Variant, aname='Result'):
    Ok: str  # Using a generic str for Ok, can be specialized if needed
    Err: Error


# Stable storage using StableBTreeMap
# Memory IDs for stable storage
USERS_MEMORY_ID = 1
USER_COURSES_MEMORY_ID = 2
USER_SKILLS_MEMORY_ID = 3
NEURO_STAKES_MEMORY_ID = 4
GENESIS_NFTS_MEMORY_ID = 5
COMBAT_ARENAS_MEMORY_ID = 6
BATTLES_MEMORY_ID = 7
REWARDS_MEMORY_ID = 8
BITCOIN_REWARDS_MEMORY_ID = 9
COURSES_MEMORY_ID = 10
SKILLS_MEMORY_ID = 11
SKILL_NFTS_MEMORY_ID = 12
ASSESSMENTS_MEMORY_ID = 13
QUESTIONS_MEMORY_ID = 14
USER_ANSWERS_MEMORY_ID = 15
ASSESSMENT_RESULTS_MEMORY_ID = 16
AI_PROMPTS_MEMORY_ID = 17
AI_RESPONSES_MEMORY_ID = 18

# User management
users = StableBTreeMap[str, User](memory_id=USERS_MEMORY_ID, max_key_size=100, max_value_size=4096)
user_courses = StableBTreeMap[str, UserCourse](memory_id=USER_COURSES_MEMORY_ID, max_key_size=100, max_value_size=4096)
user_skills = StableBTreeMap[str, UserSkill](memory_id=USER_SKILLS_MEMORY_ID, max_key_size=100, max_value_size=4096)

# Gamification
neuro_stakes = StableBTreeMap[str, NeuroStake](memory_id=NEURO_STAKES_MEMORY_ID, max_key_size=100, max_value_size=4096)
genesis_nfts = StableBTreeMap[str, GenesisNft](memory_id=GENESIS_NFTS_MEMORY_ID, max_key_size=100, max_value_size=4096)
combat_arenas = StableBTreeMap[str, CombatArena](memory_id=COMBAT_ARENAS_MEMORY_ID, max_key_size=100, max_value_size=4096)
battles = StableBTreeMap[str, Battle](memory_id=BATTLES_MEMORY_ID, max_key_size=100, max_value_size=4096)
rewards = StableBTreeMap[str, Reward](memory_id=REWARDS_MEMORY_ID, max_key_size=100, max_value_size=4096)
bitcoin_rewards = StableBTreeMap[str, BitcoinReward](memory_id=BITCOIN_REWARDS_MEMORY_ID, max_key_size=100, max_value_size=4096)

# Education
courses = StableBTreeMap[str, Course](memory_id=COURSES_MEMORY_ID, max_key_size=100, max_value_size=4096)
skills = StableBTreeMap[str, Skill](memory_id=SKILLS_MEMORY_ID, max_key_size=100, max_value_size=4096)
skill_nfts = StableBTreeMap[str, SkillNft](memory_id=SKILL_NFTS_MEMORY_ID, max_key_size=100, max_value_size=4096)
assessments = StableBTreeMap[str, Assessment](memory_id=ASSESSMENTS_MEMORY_ID, max_key_size=100, max_value_size=4096)
questions = StableBTreeMap[str, Question](memory_id=QUESTIONS_MEMORY_ID, max_key_size=100, max_value_size=4096)
user_answers = StableBTreeMap[str, UserAnswer](memory_id=USER_ANSWERS_MEMORY_ID, max_key_size=100, max_value_size=4096)
assessment_results = StableBTreeMap[str, AssessmentResult](memory_id=ASSESSMENT_RESULTS_MEMORY_ID, max_key_size=100, max_value_size=4096)

# AI Integration
ai_prompts = StableBTreeMap[str, AIPrompt](memory_id=AI_PROMPTS_MEMORY_ID, max_key_size=100, max_value_size=4096)
ai_responses = StableBTreeMap[str, AIResponse](memory_id=AI_RESPONSES_MEMORY_ID, max_key_size=100, max_value_size=4096)

# Helper functions for composite keys
def create_user_course_key(user_id: str, course_id: str) -> str:
    return f"{user_id}_{course_id}"

def create_user_skill_key(user_id: str, skill_id: str) -> str:
    return f"{user_id}_{skill_id}"

def create_question_key(assessment_id: str, question_id: str) -> str:
    return f"{assessment_id}_{question_id}"

def create_user_answer_key(user_id: str, question_id: str) -> str:
    return f"{user_id}_{question_id}"

# Timestamp helpers
def get_current_timestamp() -> int:
    """Get current timestamp in milliseconds"""
    return ic.time() // 1_000_000  # Convert nanoseconds to milliseconds

# Canister lifecycle hooks
@init
def init_function() -> None:
    """Initialize the canister state."""
    # This function is called once when the canister is deployed
    pass

# Variables to store state during upgrade
users_backup: List[Tuple[str, Dict[str, Any]]] = []
user_courses_backup: List[Tuple[str, Dict[str, Any]]] = []
user_skills_backup: List[Tuple[str, Dict[str, Any]]] = []
neuro_stakes_backup: List[Tuple[str, Dict[str, Any]]] = []
genesis_nfts_backup: List[Tuple[str, Dict[str, Any]]] = []
combat_arenas_backup: List[Tuple[str, Dict[str, Any]]] = []
battles_backup: List[Tuple[str, Dict[str, Any]]] = []
rewards_backup: List[Tuple[str, Dict[str, Any]]] = []
bitcoin_rewards_backup: List[Tuple[str, Dict[str, Any]]] = []
courses_backup: List[Tuple[str, Dict[str, Any]]] = []
skills_backup: List[Tuple[str, Dict[str, Any]]] = []
skill_nfts_backup: List[Tuple[str, Dict[str, Any]]] = []
assessments_backup: List[Tuple[str, Dict[str, Any]]] = []
questions_backup: List[Tuple[str, Dict[str, Any]]] = []
user_answers_backup: List[Tuple[str, Dict[str, Any]]] = []
assessment_results_backup: List[Tuple[str, Dict[str, Any]]] = []
ai_prompts_backup: List[Tuple[str, Dict[str, Any]]] = []
ai_responses_backup: List[Tuple[str, Dict[str, Any]]] = []

@pre_upgrade
def pre_upgrade_function() -> None:
    """Save state before canister upgrade."""
    global users_backup, user_courses_backup, user_skills_backup
    global neuro_stakes_backup, genesis_nfts_backup, combat_arenas_backup, battles_backup
    global rewards_backup, bitcoin_rewards_backup
    global courses_backup, skills_backup, skill_nfts_backup
    global assessments_backup, questions_backup, user_answers_backup, assessment_results_backup
    global ai_prompts_backup, ai_responses_backup
    
    # Backup all data
    users_backup = [(k, v) for k, v in users.items()]
    user_courses_backup = [(k, v) for k, v in user_courses.items()]
    user_skills_backup = [(k, v) for k, v in user_skills.items()]
    neuro_stakes_backup = [(k, v) for k, v in neuro_stakes.items()]
    genesis_nfts_backup = [(k, v) for k, v in genesis_nfts.items()]
    combat_arenas_backup = [(k, v) for k, v in combat_arenas.items()]
    battles_backup = [(k, v) for k, v in battles.items()]
    rewards_backup = [(k, v) for k, v in rewards.items()]
    bitcoin_rewards_backup = [(k, v) for k, v in bitcoin_rewards.items()]
    courses_backup = [(k, v) for k, v in courses.items()]
    skills_backup = [(k, v) for k, v in skills.items()]
    skill_nfts_backup = [(k, v) for k, v in skill_nfts.items()]
    assessments_backup = [(k, v) for k, v in assessments.items()]
    questions_backup = [(k, v) for k, v in questions.items()]
    user_answers_backup = [(k, v) for k, v in user_answers.items()]
    assessment_results_backup = [(k, v) for k, v in assessment_results.items()]
    ai_prompts_backup = [(k, v) for k, v in ai_prompts.items()]
    ai_responses_backup = [(k, v) for k, v in ai_responses.items()]

@post_upgrade
def post_upgrade_function() -> None:
    """Restore state after canister upgrade."""
    global users_backup, user_courses_backup, user_skills_backup
    global neuro_stakes_backup, genesis_nfts_backup, combat_arenas_backup, battles_backup
    global rewards_backup, bitcoin_rewards_backup
    global courses_backup, skills_backup, skill_nfts_backup
    global assessments_backup, questions_backup, user_answers_backup, assessment_results_backup
    global ai_prompts_backup, ai_responses_backup
    
    # Restore all data
    for k, v in users_backup:
        users.insert(k, v)
    for k, v in user_courses_backup:
        user_courses.insert(k, v)
    for k, v in user_skills_backup:
        user_skills.insert(k, v)
    for k, v in neuro_stakes_backup:
        neuro_stakes.insert(k, v)
    for k, v in genesis_nfts_backup:
        genesis_nfts.insert(k, v)
    for k, v in combat_arenas_backup:
        combat_arenas.insert(k, v)
    for k, v in battles_backup:
        battles.insert(k, v)
    for k, v in rewards_backup:
        rewards.insert(k, v)
    for k, v in bitcoin_rewards_backup:
        bitcoin_rewards.insert(k, v)
    for k, v in courses_backup:
        courses.insert(k, v)
    for k, v in skills_backup:
        skills.insert(k, v)
    for k, v in skill_nfts_backup:
        skill_nfts.insert(k, v)
    for k, v in assessments_backup:
        assessments.insert(k, v)
    for k, v in questions_backup:
        questions.insert(k, v)
    for k, v in user_answers_backup:
        user_answers.insert(k, v)
    for k, v in assessment_results_backup:
        assessment_results.insert(k, v)
    for k, v in ai_prompts_backup:
        ai_prompts.insert(k, v)
    for k, v in ai_responses_backup:
        ai_responses.insert(k, v)
    
    # Clear backup variables
    users_backup = []
    user_courses_backup = []
    user_skills_backup = []
    neuro_stakes_backup = []
    genesis_nfts_backup = []
    combat_arenas_backup = []
    battles_backup = []
    rewards_backup = []
    bitcoin_rewards_backup = []
    courses_backup = []
    skills_backup = []
    skill_nfts_backup = []
    assessments_backup = []
    questions_backup = []
    user_answers_backup = []
    assessment_results_backup = []
    ai_prompts_backup = []
    ai_responses_backup = []

# ===== User Management =====

class RegisterUserResult(Variant, aname='RegisterUserResult'):
    Ok: User
    Err: Error

@update
def register_user(username: str, email: str, btc_address: Opt[str]) -> RegisterUserResult:
    """Register a new user with the provided username, email, and optional BTC address."""
    principal = ic.caller()
    user_id = str(principal)

    if users.contains_key(user_id):
        return RegisterUserResult(Err=Error(InvalidPayload='User already registered'))

    new_user = User(
        id=principal,
        username=username,
        email=email,
        btc_address=btc_address,
        created_at=get_current_timestamp()
    )

    users.insert(user_id, new_user)
    return RegisterUserResult(Ok=new_user)

class UpdateUserResult(Variant, aname='UpdateUserResult'):
    Ok: User
    Err: Error

@update
def update_user(username: Opt[str], email: Opt[str], btc_address: Opt[str]) -> UpdateUserResult:
    """Update the current user's profile."""
    principal = ic.caller()
    user_id = str(principal)

    user_opt = users.get(user_id)
    if user_opt is None:
        return UpdateUserResult(Err=Error(NotFound='User not found'))

    user = user_opt
    if username is not None:
        user.username = username
    if email is not None:
        user.email = email
    if btc_address is not None:
        user.btc_address = btc_address

    users.insert(user_id, user)
    return UpdateUserResult(Ok=user)

class GetUserResult(Variant, aname='GetUserResult'):
    Ok: User
    Err: Error

@query
def get_user() -> GetUserResult:
    """Get the current user's profile."""
    principal = ic.caller()
    user_id = str(principal)

    user_opt = users.get(user_id)
    if user_opt is None:
        return GetUserResult(Err=Error(NotFound='User not found'))
    
    return GetUserResult(Ok=user_opt)

@query
def get_user_by_id(user_id: str) -> Opt[User]:
    """Get a user by their ID."""
    return users.get(user_id)

class ListUsersResult(Record):
    items: Vec[User]
    total: int
    skip: int
    limit: int

@query
def list_users(skip: int = 0, limit: int = 100) -> ListUsersResult:
    """List all users with pagination."""
    all_users = [user for _, user in users.items()]
    all_users.sort(key=lambda x: x.created_at, reverse=True)
    
    paginated_users = all_users[skip : skip + limit]
    
    return ListUsersResult(
        items=paginated_users,
        total=len(all_users),
        skip=skip,
        limit=limit
    )

class TrackUserCourseProgressResult(Variant, aname='TrackUserCourseProgressResult'):
    Ok: UserCourse
    Err: Error

@update
def track_user_course_progress(course_id: str, progress: int, completed: bool) -> TrackUserCourseProgressResult:
    """Track a user's progress in a course."""
    principal = ic.caller()
    user_id = str(principal)
    
    if not users.contains_key(user_id):
        return TrackUserCourseProgressResult(Err=Error(NotFound='User not found'))
    if not courses.contains_key(course_id):
        return TrackUserCourseProgressResult(Err=Error(NotFound='Course not found'))
    
    key = create_user_course_key(user_id, course_id)
    timestamp = get_current_timestamp()
    
    user_course_opt = user_courses.get(key)
    
    if user_course_opt is not None:
        user_course = user_course_opt
        user_course.progress = progress
        user_course.completed = completed
        if completed and user_course.completed_at is None:
            user_course.completed_at = Opt.Some(timestamp)
    else:
        user_course = UserCourse(
            id=key,
            user_id=principal,
            course_id=course_id,
            progress=progress,
            completed=completed,
            started_at=timestamp,
            completed_at=Opt.Some(timestamp) if completed else Opt.Null
        )
    
    user_courses.insert(key, user_course)
    return TrackUserCourseProgressResult(Ok=user_course)

class GetUserCourseProgressResult(Variant, aname='GetUserCourseProgressResult'):
    Ok: UserCourse
    Err: Error

@query
def get_user_course_progress(course_id: str) -> GetUserCourseProgressResult:
    """Get a user's progress in a specific course."""
    principal = ic.caller()
    user_id = str(principal)
    key = create_user_course_key(user_id, course_id)
    
    user_course_opt = user_courses.get(key)
    if user_course_opt is None:
        return GetUserCourseProgressResult(Err=Error(NotFound='Progress not found for this course'))
        
    return GetUserCourseProgressResult(Ok=user_course_opt)

class GetUserCoursesResult(Record):
    items: Vec[UserCourse]

@query
def get_user_courses(user_id: Opt[str]) -> GetUserCoursesResult:
    """Get all courses for a user with their progress."""
    target_user_id = str(ic.caller()) if user_id is None else user_id
    user_course_list = [uc for key, uc in user_courses.items() if key.startswith(f"{target_user_id}_")]
    return GetUserCoursesResult(items=user_course_list)


# ===== Neuro-Stake Service =====

class AddStakeResult(Variant, aname='AddStakeResult'):
    Ok: NeuroStake
    Err: Error

@update
def add_stake(amount: float, duration_days: int) -> AddStakeResult:
    """Add a new neuro-stake for the current user."""
    principal = ic.caller()
    user_id = str(principal)
    
    if not users.contains_key(user_id):
        return AddStakeResult(Err=Error(NotFound='User not found'))
    
    stake_id = f"{user_id}_{get_current_timestamp()}"
    start_date = get_current_timestamp()
    end_date = start_date + (duration_days * 24 * 60 * 60)
    
    new_stake = NeuroStake(
        id=stake_id,
        user_id=principal,
        amount=amount,
        duration_days=duration_days,
        start_date=start_date,
        end_date=end_date,
        status='active',
        streak=0,
        last_check_in=start_date
    )
    
    neuro_stakes.insert(stake_id, new_stake)
    return AddStakeResult(Ok=new_stake)

class UpdateStakeStatusResult(Variant, aname='UpdateStakeStatusResult'):
    Ok: NeuroStake
    Err: Error

@update
def update_stake_status(stake_id: str, status: str) -> UpdateStakeStatusResult:
    """Update the status of a neuro-stake."""
    stake_opt = neuro_stakes.get(stake_id)
    if stake_opt is None:
        return UpdateStakeStatusResult(Err=Error(NotFound='Stake not found'))
    
    stake = stake_opt
    principal = ic.caller()
    if stake.user_id != principal:
        return UpdateStakeStatusResult(Err=Error(Unauthorized='Unauthorized'))
        
    stake.status = status
    neuro_stakes.insert(stake_id, stake)
    return UpdateStakeStatusResult(Ok=stake)

@query
def get_stake(stake_id: str) -> Opt[NeuroStake]:
    """Get a neuro-stake by its ID."""
    return neuro_stakes.get(stake_id)

class GetUserStakesResult(Record):
    items: Vec[NeuroStake]

@query
def get_user_stakes(user_id: Opt[str]) -> GetUserStakesResult:
    """Get all neuro-stakes for a user."""
    target_user_id = str(ic.caller()) if user_id is None else user_id
    user_stakes_list = [s for _, s in neuro_stakes.items() if str(s.user_id) == target_user_id]
    return GetUserStakesResult(items=user_stakes_list)

# ===== Genesis NFT Service =====

class MintNftResult(Variant, aname='MintNftResult'):
    Ok: GenesisNft
    Err: Error

@update
def mint_nft(name: str, description: str, image_url: str, attributes: Vec[NftAttribute]) -> MintNftResult:
    """Mint a new NFT with the provided metadata."""
    principal = ic.caller()
    user_id = str(principal)
    
    if not users.contains_key(user_id):
        return MintNftResult(Err=Error(NotFound='User not found'))
    
    timestamp = get_current_timestamp()
    nft_id = f"nft_{user_id}_{timestamp}"
    
    new_nft = GenesisNft(
        id=nft_id,
        owner_id=principal,
        name=name,
        description=description,
        image_url=image_url,
        attributes=attributes,
        minted_at=timestamp
    )
    
    genesis_nfts.insert(nft_id, new_nft)
    return MintNftResult(Ok=new_nft)

class GetUserNftsResult(Record):
    items: Vec[GenesisNft]
    total: int

@query
def get_user_nfts(user_id: Opt[str]) -> GetUserNftsResult:
    """Get all NFTs owned by a user."""
    target_user_id = ic.caller() if user_id is None else Principal.from_str(user_id)
    
    user_nfts = [n for _, n in genesis_nfts.items() if n.owner_id == target_user_id]
    
    return GetUserNftsResult(items=user_nfts, total=len(user_nfts))

@query
def get_nft(nft_id: str) -> Opt[GenesisNft]:
    """Get a specific NFT by ID."""
    return genesis_nfts.get(nft_id)

class TransferNftResult(Variant, aname='TransferNftResult'):
    Ok: GenesisNft
    Err: Error

@update
def transfer_nft(nft_id: str, to_principal: Principal) -> TransferNftResult:
    """Transfer an NFT to another user."""
    principal = ic.caller()
    
    nft_opt = genesis_nfts.get(nft_id)
    if nft_opt is None:
        return TransferNftResult(Err=Error(NotFound='NFT not found'))
    
    nft = nft_opt
    
    if nft.owner_id != principal:
        return TransferNftResult(Err=Error(Unauthorized='Unauthorized'))
    
    # Verify the recipient user exists
    if not users.contains_key(str(to_principal)):
        return TransferNftResult(Err=Error(NotFound='Recipient user not found'))
    
    nft.owner_id = to_principal
    genesis_nfts.insert(nft_id, nft)
    
    return TransferNftResult(Ok=nft)



# ===== Combat Arena Service =====

class CreateBattleResult(Variant, aname='CreateBattleResult'):
    Ok: Battle
    Err: Error

@update
def create_battle(opponent_principal: Principal, skill_ids: Vec[str], stake_amount: float) -> CreateBattleResult:
    """Create a new battle challenge."""
    player1_principal = ic.caller()
    
    if not users.contains_key(str(opponent_principal)):
        return CreateBattleResult(Err=Error(NotFound='Opponent not found'))
    
    for skill_id in skill_ids:
        if not skills.contains_key(skill_id):
            return CreateBattleResult(Err=Error(NotFound=f'Skill with id {skill_id} not found'))

    if stake_amount < 0:
        return CreateBattleResult(Err=Error(BadRequest='Stake amount cannot be negative.'))

    timestamp = get_current_timestamp()
    battle_id = f"battle_{player1_principal}_{opponent_principal}_{timestamp}"
    
    new_battle = Battle(
        id=battle_id,
        player1_id=player1_principal,
        player2_id=opponent_principal,
        skill_ids=skill_ids,
        questions=[],
        answers=[],
        status='pending',
        winner_id=None,
        created_at=timestamp,
        stake_amount=stake_amount,
        reward_claimed=False
    )
    
    battles.insert(battle_id, new_battle)
    return CreateBattleResult(Ok=new_battle)

class StartBattleResult(Variant, aname='StartBattleResult'):
    Ok: Battle
    Err: Error

@update
def start_battle(battle_id: str) -> StartBattleResult:
    """Starts a battle, generating questions."""
    principal = ic.caller()
    
    battle_opt = battles.get(battle_id)
    if battle_opt is None:
        return StartBattleResult(Err=Error(NotFound='Battle not found'))
    
    battle = battle_opt
    
    if battle.player1_id != principal and battle.player2_id != principal:
        return StartBattleResult(Err=Error(Unauthorized='You are not a player in this battle'))
    
    if battle.status != 'pending':
        return StartBattleResult(Err=Error(BadRequest='Battle has already started or is completed'))
    
    # Generate 5 random questions for the skill
    skill_questions = [q for _, q in questions.items() if q.skill_id in battle.skill_ids]
    
    if len(skill_questions) < 5:
        return StartBattleResult(Err=Error(BadRequest='Not enough questions for this skill to start a battle'))
    
    seed_str = f"{battle_id}-{'-'.join(battle.skill_ids)}"
    seed = 0
    for char in seed_str:
        seed = (seed * 31 + ord(char)) & 0xFFFFFFFF

    def lcg(seed_val):
        a = 1664525
        c = 1013904223
        m = 2**32
        return (a * seed_val + c) % m

    shuffled_questions = list(skill_questions)
    n = len(shuffled_questions)
    for i in range(n - 1, 0, -1):
        seed = lcg(seed)
        j = seed % (i + 1)
        shuffled_questions[i], shuffled_questions[j] = shuffled_questions[j], shuffled_questions[i]

    battle.questions = [q.id for q in shuffled_questions[:min(n, 10)]]
    battle.status = 'active'
    battles.insert(battle.id, battle)
    
    return StartBattleResult(Ok=battle)

# ... (rest of the code remains the same)
class SubmitAnswerResult(Variant, aname='SubmitAnswerResult'):
    Ok: Battle
    Err: Error

@update
def submit_answer(battle_id: str, question_id: str, answer_option: int) -> SubmitAnswerResult:
    """Submit an answer for a battle question."""
    principal = ic.caller()
    
    battle_opt = battles.get(battle_id)
    if battle_opt is None:
        return SubmitAnswerResult(Err=Error(NotFound='Battle not found'))
    
    battle = battle_opt
    
    if battle.player1_id != principal and battle.player2_id != principal:
        return SubmitAnswerResult(Err=Error(Unauthorized='You are not a player in this battle'))
    
    if battle.status != 'active':
        return SubmitAnswerResult(Err=Error(BadRequest='Battle is not active'))
    
    # Check if user has already answered this question
    if any(a.user_id == principal and a.question_id == question_id for a in battle.answers):
        return SubmitAnswerResult(Err=Error(BadRequest='You have already answered this question'))

    battle.answers.append(BattleAnswer(user_id=principal, question_id=question_id, answer_option=answer_option))
    
    # Check if battle is complete
    p1_answers = [a for a in battle.answers if a.user_id == battle.player1_id]
    p2_answers = [a for a in battle.answers if a.user_id == battle.player2_id]

    if len(p1_answers) == len(battle.questions) and len(p2_answers) == len(battle.questions):
        p1_score = sum(1 for a in p1_answers if any(q.id == a.question_id and q.correct_option == a.answer_option for q in battle.questions))
        p2_score = sum(1 for a in p2_answers if any(q.id == a.question_id and q.correct_option == a.answer_option for q in battle.questions))

        if p1_score > p2_score:
            battle.winner_id = battle.player1_id
        elif p2_score > p1_score:
            battle.winner_id = battle.player2_id
        
        battle.status = 'completed'

    battles.insert(battle.id, battle)
    return SubmitAnswerResult(Ok=battle)

class ClaimRewardResult(Variant, aname='ClaimRewardResult'):
    Ok: str
    Err: Error

@update
def claim_battle_reward(battle_id: str) -> ClaimRewardResult:
    """Claim the reward for a completed battle."""
    principal = ic.caller()
    
    battle_opt = battles.get(battle_id)
    if battle_opt is None:
        return ClaimRewardResult(Err=Error(NotFound='Battle not found'))
    
    battle = battle_opt
    
    if battle.status != 'completed':
        return ClaimRewardResult(Err=Error(BadRequest='Battle is not completed'))
    
    if battle.winner_id is None or battle.winner_id != principal:
        return ClaimRewardResult(Err=Error(Unauthorized='You are not the winner of this battle'))
        
    if battle.reward_claimed:
        return ClaimRewardResult(Err=Error(BadRequest='Reward has already been claimed'))

    user_opt = users.get(str(principal))
    if user_opt is None:
        return ClaimRewardResult(Err=Error(NotFound='User not found'))
    
    user = user_opt
    # For now, reward is XP. Stake transfer would happen here.
    user.xp += 100  # 100 XP for winning a battle
    users.insert(user.id, user)
    
    battle.reward_claimed = True
    battles.insert(battle.id, battle)
    
    return ClaimRewardResult(Ok='Reward claimed successfully, 100 XP gained')

class GetUserBattlesResult(Record):
    items: Vec[Battle]

@query
def get_user_battles(user_id: Opt[str]) -> GetUserBattlesResult:
    """Get all battles for a user."""
    target_user_id = ic.caller() if user_id is None else Principal.from_str(user_id)
    
    user_battles_list = [b for _, b in battles.items() if b.player1_id == target_user_id or b.player2_id == target_user_id]
    
    return GetUserBattlesResult(items=user_battles_list)

@query
def get_battle(battle_id: str) -> Opt[Battle]:
    """Get a specific battle by ID."""
    return battles.get(battle_id)

# ===== Course Service =====

class CreateCourseResult(Variant, aname='CreateCourseResult'):
    Ok: Course
    Err: Error

@update
def create_course(title: str, description: str, topic: str, difficulty: int) -> CreateCourseResult:
    """Create a new course with the provided details."""
    course_id = f"course_{get_current_timestamp()}"
    timestamp = get_current_timestamp()
    creator_id = ic.caller()
    
    new_course = Course(
        id=course_id,
        title=title,
        description=description,
        topic=topic,
        difficulty=difficulty,
        content='',
        image_url=None,
        dependencies=[],
        skill_ids=[],
        created_at=timestamp,
        updated_at=timestamp,
        creator_id=creator_id,
        is_published=False
    )
    
    courses.insert(course_id, new_course)
    return CreateCourseResult(Ok=new_course)

class UpdateCoursePayload(Record):
    title: Opt[str]
    description: Opt[str]
    topic: Opt[str]
    difficulty: Opt[int]
    content: Opt[str]
    image_url: Opt[str]
    is_published: Opt[bool]
    dependencies: Opt[Vec[str]]
    skill_ids: Opt[Vec[str]]

class UpdateCourseResult(Variant, aname='UpdateCourseResult'):
    Ok: Course
    Err: Error

@update
def update_course(course_id: str, payload: UpdateCoursePayload) -> UpdateCourseResult:
    """Update an existing course."""
    course_opt = courses.get(course_id)
    if course_opt is None:
        return UpdateCourseResult(Err=Error(NotFound='Course not found'))
    
    course = course_opt
    
    if payload.title:
        course.title = payload.title
    if payload.description:
        course.description = payload.description
    if payload.topic:
        course.topic = payload.topic
    if payload.difficulty:
        course.difficulty = payload.difficulty
    if payload.content:
        course.content = payload.content
    if payload.image_url:
        course.image_url = payload.image_url
    if payload.is_published:
        course.is_published = payload.is_published
    if payload.dependencies:
        course.dependencies = payload.dependencies
    if payload.skill_ids:
        course.skill_ids = payload.skill_ids
    
    course.updated_at = get_current_timestamp()
    courses.insert(course_id, course)
    
    return UpdateCourseResult(Ok=course)

class DeleteCourseResult(Variant, aname='DeleteCourseResult'):
    Ok: str
    Err: Error

@update
def delete_course(course_id: str) -> DeleteCourseResult:
    """Delete a course by its ID."""
    course_opt = courses.remove(course_id)
    if course_opt is None:
        return DeleteCourseResult(Err=Error(NotFound='Course not found'))
    
    # Also delete related assessments
    assessment_ids_to_remove = [a_id for a_id, a in assessments.items() if a.course_id == course_id]
    for assessment_id in assessment_ids_to_remove:
        assessments.remove(assessment_id)
    
    return DeleteCourseResult(Ok=f'Course {course_id} deleted successfully')

@query
def get_course(course_id: str) -> Opt[Course]:
    """Get a course by its ID."""
    return courses.get(course_id)

class ListCoursesResult(Record):
    items: Vec[Course]
    total: int

class ListCoursesParams(Record):
    skip: int
    limit: int
    topic: Opt[str]
    difficulty: Opt[int]
    published_only: Opt[bool]
    creator_id: Opt[str]

@query
def list_courses(params: ListCoursesParams) -> ListCoursesResult:
    """List all available courses with optional filtering and pagination."""
    all_courses = [c for _, c in courses.items()]
    
    # Apply filters
    if params.topic is not None:
        all_courses = [c for c in all_courses if c.topic == params.topic]
    if params.difficulty is not None:
        all_courses = [c for c in all_courses if c.difficulty == params.difficulty]
    if params.published_only is not None and params.published_only:
        all_courses = [c for c in all_courses if c.is_published]
    if params.creator_id is not None:
        creator_principal = Principal.from_str(params.creator_id)
        all_courses = [c for c in all_courses if c.creator_id == creator_principal]
        
    total = len(all_courses)
    
    # Sort and paginate
    all_courses.sort(key=lambda x: x.created_at, reverse=True)
    paginated_courses = all_courses[params.skip:params.skip+params.limit]
    
    return ListCoursesResult(items=paginated_courses, total=total)

class CreateSkillResult(Variant, aname='CreateSkillResult'):
    Ok: Skill
    Err: Error

class CreateSkillParams(Record):
    name: str
    description: str
    difficulty: int
    concept_id: Opt[str]
    parent_skill_id: Opt[str]
    course_ids: Opt[Vec[str]]
    dependencies: Opt[Vec[str]]

@update
def create_skill(params: CreateSkillParams) -> CreateSkillResult:
    """Create a new skill."""
    if not 1 <= params.difficulty <= 5:
        return CreateSkillResult(Err=Error(InvalidInput='Skill difficulty must be between 1 and 5'))

    if params.parent_skill_id is not None and skills.get(params.parent_skill_id) is None:
        return CreateSkillResult(Err=Error(NotFound='Parent skill not found'))

    if params.dependencies is not None:
        for dep_id in params.dependencies:
            if skills.get(dep_id) is None:
                return CreateSkillResult(Err=Error(NotFound=f'Dependency skill {dep_id} not found'))

    skill_id = f"skill_{get_current_timestamp()}"
    timestamp = get_current_timestamp()
    
    new_skill = Skill(
        id=skill_id,
        name=params.name,
        description=params.description,
        difficulty=params.difficulty,
        concept_id=params.concept_id,
        parent_skill_id=params.parent_skill_id,
        dependencies=params.dependencies,
        course_ids=params.course_ids,
        created_at=timestamp,
        updated_at=timestamp,
        created_by=ic.caller()
    )
    
    skills.insert(skill_id, new_skill)
    return CreateSkillResult(Ok=new_skill)

class ListSkillsResult(Record):
    items: Vec[Skill]
    total: int

class ListSkillsParams(Record):
    skip: int
    limit: int
    difficulty: Opt[int]
    parent_skill_id: Opt[str]
    course_id: Opt[str]
    concept_id: Opt[str]

@query
def list_skills(params: ListSkillsParams) -> ListSkillsResult:
    """List all skills, optionally filtered."""
    all_skills = [s for _, s in skills.items()]

    if params.difficulty is not None:
        all_skills = [s for s in all_skills if s.difficulty == params.difficulty]
    if params.parent_skill_id is not None:
        all_skills = [s for s in all_skills if s.parent_skill_id == params.parent_skill_id]
    if params.course_id is not None:
        all_skills = [s for s in all_skills if params.course_id in s.course_ids]
    if params.concept_id is not None:
        all_skills = [s for s in all_skills if s.concept_id == params.concept_id]
        
    total = len(all_skills)

class ListUserSkillsResult(Record):
    items: Vec[EnrichedUserSkill]
    total: int

class GetUserSkillsParams(Record):
    user_id: Opt[str]
    min_mastery: Opt[int]
    max_mastery: Opt[int]
    has_nft: Opt[bool]
    skip: int
    limit: int

@query
def get_user_skills(params: GetUserSkillsParams) -> ListUserSkillsResult:
    """Get all skills for a user with their mastery levels, with filtering and pagination."""
    target_user_id_str = params.user_id if params.user_id is not None else str(ic.caller())
    target_user_id = Principal.from_str(target_user_id_str)

    if users.get(target_user_id) is None:
        return ListUserSkillsResult(items=[], total=0)

    matching_skills = []
    for _, user_skill in user_skills.items():
        if user_skill.user_id == target_user_id:
            if params.min_mastery is not None and user_skill.mastery_level < params.min_mastery: continue
            if params.max_mastery is not None and user_skill.mastery_level > params.max_mastery: continue
            if params.has_nft is not None and (user_skill.nft_token_id is not None) != params.has_nft: continue
            matching_skills.append(user_skill)

    matching_skills.sort(key=lambda x: x.mastery_level, reverse=True)
    total = len(matching_skills)
    paginated_user_skills = matching_skills[params.skip:params.skip+params.limit]

    enriched_result = []
    for us in paginated_user_skills:
        skill_opt = skills.get(us.skill_id)

@update
def create_assessment(params: CreateAssessmentParams) -> CreateAssessmentResult:
    """Create a new assessment."""
    if not 0 <= params.passing_score <= 100:
        return CreateAssessmentResult(Err=Error(InvalidInput='Passing score must be between 0 and 100'))
    if courses.get(params.course_id) is None:
        return CreateAssessmentResult(Err=Error(NotFound='Course not found'))
    for skill_id in params.skill_ids:
        if skills.get(skill_id) is None:
            return CreateAssessmentResult(Err=Error(NotFound=f'Skill {skill_id} not found'))

    assessment_id = f"assessment_{get_current_timestamp()}"
    timestamp = get_current_timestamp()
    
    new_assessment = Assessment(
        id=assessment_id,
        title=params.title,
        description=params.description,
        course_id=params.course_id,
        skill_ids=params.skill_ids,
        time_limit_minutes=params.time_limit_minutes,
        passing_score=params.passing_score,
        created_at=timestamp,
        updated_at=timestamp,
        creator_id=ic.caller(),
        questions=[]
    )
    
    assessments.insert(assessment_id, new_assessment)
    return CreateAssessmentResult(Ok=new_assessment)

# ... (rest of the code remains the same)

class TrackUserSkillParams(Record):
    skill_id: str
    mastery_level: int

@update
def track_user_skill_mastery(params: TrackUserSkillParams) -> TrackUserSkillResult:
    """Track user skill mastery."""
    user_id = ic.caller()
    skill_opt = skills.get(params.skill_id)
    if skill_opt is None:
        return TrackUserSkillResult(Err=Error(NotFound='Skill not found'))
    # ... (rest of the function implementation remains the same)

# ... (rest of the code remains the same)

class GenerateSkillNftMetadataParams(Record):
    skill_id: str
    mastery_level: int

@update
def generate_skill_nft_metadata(params: GenerateSkillNftMetadataParams) -> GenerateSkillNftMetadataResult:
    """Generate metadata for a skill NFT."""
    user_id = ic.caller()
    skill_opt = skills.get(params.skill_id)
    if skill_opt is None:
        return GenerateSkillNftMetadataResult(Err=Error(NotFound='Skill not found'))
    # ... (rest of the function implementation remains the same)
    skill = skill_opt
    timestamp = get_current_timestamp()
    prompt_id = f"prompt_nft_{str(user_id)}_{timestamp}"
    
    prompt_params = f'{{"skill_id": "{skill_id}", "mastery_level": {mastery_level}}}'
    new_prompt = AIPrompt(
        id=prompt_id, user_id=user_id, prompt_type="skill_nft", parameters=prompt_params,
        prompt=f"Generate NFT metadata for skill '{skill.name}' with mastery level {mastery_level}",
        created_at=timestamp
    )
    ai_prompts.insert(prompt_id, new_prompt)
    
    metadata_str = f'{{ "name": "{skill.name} Mastery - Level {mastery_level}" }}'
    response_id = f"response_{prompt_id}"
    new_response = AIResponse(
        id=response_id, prompt_id=prompt_id, user_id=user_id,
        content=metadata_str, created_at=timestamp
    )
    ai_responses.insert(response_id, new_response)
    return GenerateSkillNftMetadataResult(Ok=new_response)

# ===== Bitcoin Reward Service =====

class CreateBitcoinRewardResult(Variant, aname='CreateBitcoinRewardResult'):
    Ok: BitcoinReward
    Err: Error

@update
def create_bitcoin_reward(user_id: str, amount: float64, skill_ids: Vec[str]) -> CreateBitcoinRewardResult:
    """Create a new Bitcoin reward for a user based on their skills."""
    try:
        user_principal = Principal.from_str(user_id)
    except Exception:
        return CreateBitcoinRewardResult(Err=Error(InvalidInput='Invalid user ID format'))

    if users.get(user_principal) is None:
        return CreateBitcoinRewardResult(Err=Error(NotFound='User not found'))
    
    timestamp = get_current_timestamp()
    reward_id = f"btc_reward_{user_id}_{timestamp}"
    
    new_reward = BitcoinReward(
        id=reward_id, user_id=user_principal, amount=amount, skill_ids=skill_ids, 
        created_at=timestamp, status="pending", transaction_hash=None, processed_at=None, 
        wallet_address=None, claimed_at=None
    )
    bitcoin_rewards.insert(reward_id, new_reward)
    return CreateBitcoinRewardResult(Ok=new_reward)

class ProcessBitcoinRewardResult(Variant, aname='ProcessBitcoinRewardResult'):
    Ok: BitcoinReward
    Err: Error

@update
def process_bitcoin_reward(reward_id: str) -> ProcessBitcoinRewardResult:
    """Process a pending Bitcoin reward."""
    reward_opt = bitcoin_rewards.get(reward_id)
    if reward_opt is None:
        return ProcessBitcoinRewardResult(Err=Error(NotFound='Reward not found'))
    
    reward = reward_opt
    reward.status = "completed"
    reward.processed_at = get_current_timestamp()
    reward.transaction_hash = f"0x{get_current_timestamp()}"
    bitcoin_rewards.insert(reward_id, reward)
    return ProcessBitcoinRewardResult(Ok=reward)

class ListBitcoinRewardsResult(Record):
    items: Vec[BitcoinReward]
    total: int

@query
def get_user_bitcoin_rewards(skip: int, limit: int, user_id: Opt[str], status: Opt[str]) -> ListBitcoinRewardsResult:
    """Get all Bitcoin rewards for a user, optionally filtered by status."""
    target_user_id_str = user_id[0] if user_id else str(ic.caller())
    try:
        target_user_id = Principal.from_str(target_user_id_str)
    except Exception:
        return ListBitcoinRewardsResult(items=[], total=0)

    user_rewards = [r for _, r in bitcoin_rewards.items() if r.user_id == target_user_id]
    if status: user_rewards = [r for r in user_rewards if r.status == status[0]]
    
    total = len(user_rewards)
    user_rewards.sort(key=lambda r: r.created_at, reverse=True)
    return ListBitcoinRewardsResult(items=user_rewards[skip:skip+limit], total=total)

class GetBitcoinRewardResult(Variant, aname='GetBitcoinRewardResult'):
    Ok: BitcoinReward
    Err: Error

@query
def get_bitcoin_reward(reward_id: str) -> GetBitcoinRewardResult:
    """Get a specific Bitcoin reward by ID."""
    reward_opt = bitcoin_rewards.get(reward_id)
    if reward_opt is None:
        return GetBitcoinRewardResult(Err=Error(NotFound='Reward not found'))
    return GetBitcoinRewardResult(Ok=reward_opt)

class ClaimBitcoinRewardResult(Variant, aname='ClaimBitcoinRewardResult'):
    Ok: BitcoinReward
    Err: Error

@update
def claim_bitcoin_reward(reward_id: str, wallet_address: str) -> ClaimBitcoinRewardResult:
    """Claim a Bitcoin reward by providing a wallet address."""
    reward_opt = bitcoin_rewards.get(reward_id)
    if reward_opt is None:
        return ClaimBitcoinRewardResult(Err=Error(NotFound='Reward not found'))
    
    reward = reward_opt
    if reward.user_id != ic.caller():
        return ClaimBitcoinRewardResult(Err=Error(Unauthorized='This reward belongs to another user'))
    if reward.status != "pending":
        return ClaimBitcoinRewardResult(Err=Error(InvalidInput=f'Reward is already {reward.status}'))
    
    reward.status = "claimed"
    reward.wallet_address = [wallet_address]
    reward.claimed_at = [get_current_timestamp()]
    bitcoin_rewards.insert(reward_id, reward)
    return ClaimBitcoinRewardResult(Ok=reward)

# ===== System Info =====

class CanisterInfo(Record):
    name: str
    version: str
    description: str
    time: nat64

@query
def get_canister_info() -> CanisterInfo:
    """Get information about the canister."""
    return CanisterInfo(
        name="ICPlearn Backend",
        version="1.0.0",
        description="ICPlearn backend ported to Internet Computer Protocol",
        time=ic.time()
    )
